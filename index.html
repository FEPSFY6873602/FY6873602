<!DOCTYPE html>
<html>
    <head>
        <head>
            <br>
            <img src="WebBanner2024.png" alt="Banner" style="max-width: 90%; height: auto; display: block;">
            <h1><b>ENG0018 Computer Laboratory 2024/25</b></h1>
            <h2>Student URN: 6873602</h2>
            <hr>
            <h2 style="font-family:monospace;"><b>Conference Paper: Investigating the Efficiency of Memory Management in Java vs. C++</b></h2>
            <hr>

            <!style for tables>
            <style>
                table {
                    font-family: monospace;
                    border-collapse: collapse;
                    width: 30%;
                    margin: left;
                    background-color: #e6f2ff;
                    border-radius: 8px;
                    overflow: hidden;
                    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
                }

                th {
                    background-color: #007bff;
                    font-family: monospace;
                    color: white;
                    padding: 10px;
                }

                td {
                    padding: 8px;
                    font-family: monospace;
                    border: 1px solid #d6e9f5;
                    text-align: left;
                }

                tr:nth-child(even) {
                    background-color: #f0f8ff;
                }
            </style>

            <style>
                h1, h2, h3, h4{
                    font-family: monospace;
                    color: #003366;
                    text-align: left;
                }

                p, a {
                    font-family: monospace;
                    font: 300;
                    font-size: larger;
                    color: #004080;
                    line-height: 1.6;
                    text-align: left;
                }
            </style>
        </head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link  rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
        <style>
            .myslides {display: none;}
        </style>
        <body style="background-color:#f0f8ff; margin-left:50px;"></body>

        <!table of contents>
        <table>
            <tr>
                <th><h3>Table of Contents</h3></th>
            </tr>

            <tr>
                <td><a href="#Abstract">Abstract</a></td>
            </tr>

            <tr>
                <td><a href="#Introduction">Introduction</a></td>
            </tr>

            <tr>
                <td><a href="#Analysis and Discussion">Analysis and Discussion</a></td>
            </tr>

            <tr>
                <td><a href="#References">References</a></td>
            </tr>
        </table>

        <h3 id="Abstract">Abstract</h3>
        <p>
            <div id="Abstract_Text" style="display: flex; flex-wrap: wrap;">
                <p>
                    This article explores the contrasting memory management techniques in two widely used programming languages: Java and C++. Memory management is critical to application performance, particularly in systems with constrained resources. Java uses automatic memory management through garbage collection, which provides ease of use but has a runtime overhead. On the other hand, C++ requires explicit memory control, offering potential performance benefits at the cost of complexity. While Java offers simplicity and reduces memory leaks, C++ grants developers control over memory, which can lead to more optimised performance if managed properly. This essay compares the efficiency of memory management between the two languages by analysing their techniques, tools, and performance trade-offs.
                </p>
            </div>
        </p>

        <h3 id="Introduction">Introduction</h3>
        <p>
            <div id="Introduction_Text" style="display: flex; flex-wrap: wrap;">
                <p>
                    Memory management is crucial for programming, affecting speed, efficiency, and reliability. Java and C++ showcase automatic and manual approaches, respectively. Java uses automatic garbage collection to reclaim memory from unused objects, reducing memory leaks and simplifying development. In contrast, C++ offers developers full control over memory allocation and deallocation, allowing for optimisation but increasing the risk of errors. While Java simplifies memory management, C++ provides greater control at the cost of complexity. This article compares Java and C++ memory management techniques, highlighting their advantages, disadvantages, and performance impacts.
                </p>
            </div>
        </p>

        <h3 id="Analysis and Discussion">Analysis and Discussion</h3>
        <p>
            <div id="Analysis_and_Discussion_Text" style="display: flex; flex-wrap: wrap;">
                <div style="flex: 1">
                    <h4>Memory Management in Java</h4>
                    <p>Java’s memory management system is designed to be automatic, offering a high level of abstraction that shields developers from the complexity of manual memory handling. The cornerstone of Java’s memory management is its garbage collection (GC) mechanism, which automatically reclaims memory occupied by objects that are no longer in use. Garbage collection works by identifying objects that are no longer reachable by any part of the program and removing them, thereby freeing up memory for reuse.

                        <br></br>

                        Boehm and Weiser (1988) emphasised that garbage collection in uncooperative environments requires sophisticated algorithms to ensure efficiency and stability, a principle exemplified by Java's approach. The Java Virtual Machine (JVM) employs a variety of garbage collection algorithms, including generational garbage collection, reference counting, and mark-and-sweep (Jones, Hosking, and Moss, 2012). Generational garbage collection, for example, divides objects into generations based on their age, which allows the system to collect short-lived objects more efficiently. Java's garbage collection process prevents issues like dangling pointers and memory leaks that can occur in languages with manual memory management. Furthermore, modern garbage collectors like Garbage-First (G1), Shenandoah, and ZGC have been developed to minimise performance trade-offs. These collectors aim to reduce the latency caused by garbage collection pauses, known as “stop-the-world” events, by collecting memory in parallel or incrementally (Beronić et al., 2022). Shahriyar et al. (2012) argues that a hybrid approach such as combining reference counting and garbage collection, might offer more balanced solutions in certain scenarios.
                        
                        <br></br>

                        While garbage collection improves safety and ease of use, it has performance costs. "Stop-the-world" events cause latency, which can disrupt time-sensitive applications like video games or high-frequency trading, leading to delays (Henriques and Bernardino, 2018). Additionally, garbage collection may result in higher memory consumption because the JVM does not release memory as efficiently as a manual system. This deferred memory reclamation can cause issues in constrained environments like embedded systems (Drepper, 2007).

                        <br></br>
                    </p>

                    <h4>Memory Management in C++</h4>
                    <p>In contrast to Java, C++ adopts a manual approach to memory management. Developers are directly responsible for allocating and deallocating memory, typically using operators like new and delete. This gives C++ programmers fine-grained control over memory usage, allowing them to optimise performance and manage resources based on the specific needs of their applications. For example, developers can allocate memory only when it is needed, deallocate it immediately after use, and reuse memory in ways that might be impossible with Java’s automatic garbage collection.

                        <br></br>

                        The main advantage of C++’s manual memory management is its potential for high-performance applications. With no background garbage collection, there are no execution interruptions. C++ applications achieve better memory utilisation and lower latency by fine-tuning memory allocations, which is crucial for performance-critical systems like video games, real-time simulations, and embedded devices (Henriques and Bernardino, 2018). Additionally, hardware-level optimisations in C++ allow direct interactions with memory and CPU, ideal for maximum performance requirements (Drepper, 2007).
                        
                        <br></br>

                        Manual memory management offers control but comes with risks. Developers must allocate and deallocate memory explicitly, and errors can lead to memory leaks, dangling pointers, or segmentation faults, making debugging difficult and applications unstable. Modern C++ introduces smart pointers (std::shared_ptr, std::unique_ptr) and RAII patterns to automate some memory management and enhance safety without compromising performance (Drepper, 2007). Despite these tools, C++ memory management remains complex, especially for large-scale systems.

                        <br></br>
                    </p>

                    <h4>Conclusion</h4>
                    <p>When comparing Java and C++, several trade-offs emerge. Java’s garbage collection system offers significant advantages in terms of developer productivity and ease of use. The automatic memory management system helps prevent common issues such as memory leaks and dangling pointers, reducing the likelihood of bugs and improving software reliability. However, this ease of use comes at the cost of performance. Garbage collection can introduce pauses in the application’s execution, leading to latency that can be particularly problematic in time-sensitive applications. Furthermore, the JVM’s abstraction of hardware resources results in lower performance compared to C++, which can interact more directly with the underlying hardware (Henriques and Bernardino, 2018).
                        

                        <br></br>

                        C++, on the other hand, offers more precise control over memory, which can lead to better performance, particularly in resource-constrained environments. The absence of garbage collection interruptions means that C++ applications can achieve lower latency and more efficient memory usage. However, this control also comes with increased complexity, as developers must manually manage memory and ensure that all allocations and deallocations are handled correctly. The risks associated with manual memory management, such as memory leaks and segmentation faults, can lead to stability issues and harder-to-maintain codebases.
                        
                        <br></br>

                        The decision between Java and C++ depends largely on the requirements of the specific application. For applications where development speed, safety, and robustness are paramount—such as enterprise software, web applications, or mobile apps—Java is often the preferred choice. Its automatic garbage collection and higher-level abstractions make it easier for developers to build reliable software quickly. Conversely, for performance-critical systems such as embedded devices, high-performance games, or real-time simulations, C++ is often favoured for its ability to optimise memory usage and processing speed, despite the added complexity.
                    </p>
                </div>
            </div>
        </p>

        <p>
            Click <a href="https://github.com/C0drMan0o0o/Garbage-Collector">here</a> to view an example of a simple Garbage Collector (Single Threaded Applications only) implemented in C++
        </p>
        
        <h3 id="References">References</h3>
        <p>
            <div id="References_Text" class="flex-container">
                <div class="flex-item">
                    <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=6434aa10f3745dcf959cfca9c379aae120396724">Boehm, H.-J. and Weiser, M. (1988) ‘Garbage Collection in an Uncooperative Environment’, Software: Practice and Experience, 18(9), pp. 807–820.</a>
                </div>
                <br>
                <div class="flex-item">
                    <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9803445">Beronić, D., Novosel, N., Mihaljević, B. and Radovan, A. (2022). Assessing Contemporary Automated Memory Management in Java – Garbage First, Shenandoah, and Z Garbage Collectors Comparison.</a>
                </div>
                <br>
                <div class="flex-item">
                    <a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">Drepper, U. (2007) What Every Programmer Should Know About Memory</a>
                </div>
                <br>
                <div class="flex-item">
                    <a href="https://www.taylorfrancis.com/books/mono/10.1201/9781315388021/garbage-collection-handbook-richard-jones-antony-hosking-eliot-moss">Jones, R. E., Hosking, A. L. and Moss, E. G. (2012) The Garbage Collection Handbook: The Art of Automatic Memory Management. Chapman & Hall.</a>
                </div>
                <br>
                <div class="flex-item">
                    <a href="https://dl-acm-org.surrey.idm.oclc.org/doi/pdf/10.1145/2544173.2509527">Shahriyar, R., Blackburn, S. M., Frampton, D. and McKinley, K. S. (2012) ‘Taking off the Gloves with Reference Counting Immix’, ACM SIGPLAN Notices, 47(6), pp. 93-110.</a>
                </div>
                <br>
                <div class="flex-item">
                    <a href="https://aisel.aisnet.org/cgi/viewcontent.cgi?article=1009&context=capsi2018">Henriques, L. and Bernardino, J. (2018) ‘Performance of Memory Deallocation in C++, C# and Java’, CAPSI 2018 Proceedings.</a>
                </div>
            </div>
        </p>
        <video src="ENG0018 Presentation.mp4" width="800"; height="450" controls></video>
    </head>
    
    <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- ////////////////////////////// Adding last update ////////////////////////////// -->
    <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Last commit time display -->
    <div id="last-updated" class="last-modified">Loading last update time...</div>
    <!-- Verify Button -->
    <button onclick="verifyLastUpdatedTime()">
        Verify Last Modified Time
    </button>
    <style>
        button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        
        button:hover {
            background-color: #0056b3;
        }   
    </style>
    
    <style>
        .last-modified {
            font-family: monospace;
            color: #004080; 
            font-size: 18px;
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #007bff;
            border-radius: 5px;
            background-color: #e6f2ff;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
        }
    </style>

    <script>
        async function getLastUpdatedTime() {
            const username = "FEPSFY6873602";
            const repo = "FY6873602";
        
            const url = `https://api.github.com/repos/${username}/${repo}/commits`;
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                    }
                });
                if (!response.ok) {
                    throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
                }
                const commits = await response.json();
                if (commits && commits.length > 0) {
                    const lastCommitDate = new Date(commits[0].commit.committer.date);
                
                    // Displaying the time on load
                    document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
                } else {
                    document.getElementById('last-updated').innerText = 'No commits found in the repository.';
                }
            } catch (error) {
                console.error('Error fetching the last updated time:', error);
                document.getElementById('last-updated').innerText = 'Error fetching update time. Please check the repository details.';
            }
        }
        // Function to verify the last update time by re-fetching it from the API
        async function verifyLastUpdatedTime() {
            document.getElementById('last-updated').innerText = 'Verifying...';
            await getLastUpdatedTime();
            alert("Last modified time has been successfully verified from GitHub API.");
        }
        // Initial load to display the time on page load
        window.onload = getLastUpdatedTime;
    </script>

    <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- ////////////////////////////// Word count function ////////////////////////////// -->
    <!-- //////////////////////////////////////////////////////////////////////////////// -->
    <!-- Placeholder for total word count -->
    <p id="totalWordCount" class="totalWordCount"></p>

    <style>
        .totalWordCount {
            font-family: monospace;
            color: #004080; 
            font-size: 18px;
            text-align: left;
            margin: 20px 0;
            padding: 10px;            
        }
    </style>

    <hr>
    <script>
        // Function to calculate and display word count for a specified section
        function displayWordCount(sectionId, outputId) {
            // Get the text content from the specified section
            const text = document.getElementById(sectionId).textContent;
            // Split text into words based on spaces and filter out any empty strings
            const wordArray = text.trim().split(/\s+/);
            // Count the words
            const wordCount = wordArray.length;
            // Return the word count for summing purposes
            return wordCount;
        }
        // Function to calculate and display total word count from selected sections
        function displayTotalWordCount() {
            // Calculate word count for each section and accumulate the total
            const IntroductionCount = displayWordCount("Introduction_Text");
            const AnalysisCount = displayWordCount("Analysis_and_Discussion_Text");
            // Calculate the sum of all selected sections
            const totalWordCount = IntroductionCount + AnalysisCount;
            // Display the total word count
            document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
        }
        // Run the function for specific sections and display total count when the page loads
        window.onload = displayTotalWordCount;
    </script>
</html>

